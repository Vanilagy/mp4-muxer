var h=new Uint8Array(8),w=new DataView(h.buffer),p=t=>[(t%256+256)%256],d=t=>(w.setUint16(0,t,!1),[h[0],h[1]]),Q=t=>(w.setInt16(0,t,!1),[h[0],h[1]]),H=t=>(w.setUint32(0,t,!1),[h[1],h[2],h[3]]),o=t=>(w.setUint32(0,t,!1),[h[0],h[1],h[2],h[3]]),Y=t=>(w.setInt32(0,t,!1),[h[0],h[1],h[2],h[3]]),S=t=>(w.setUint32(0,Math.floor(t/2**32),!1),w.setUint32(4,t,!1),[h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7]]),V=t=>(w.setInt16(0,2**8*t,!1),[h[0],h[1]]),C=t=>(w.setInt32(0,2**16*t,!1),[h[0],h[1],h[2],h[3]]),$=t=>(w.setInt32(0,2**30*t,!1),[h[0],h[1],h[2],h[3]]),T=(t,e=!1)=>{let i=Array(t.length).fill(null).map((r,s)=>t.charCodeAt(s));return e&&i.push(0),i},B=t=>t&&t[t.length-1],N=t=>{let e;for(let i of t)(!e||i.presentationTimestamp>e.presentationTimestamp)&&(e=i);return e},g=(t,e,i=!0)=>{let r=t*e;return i?Math.round(r):r},W=t=>{let e=t*(Math.PI/180),i=Math.cos(e),r=Math.sin(e);return[i,r,0,-r,i,0,0,0,1]},q=W(0),X=t=>[C(t[0]),C(t[1]),$(t[2]),C(t[3]),C(t[4]),$(t[5]),C(t[6]),C(t[7]),$(t[8])],A=t=>!t||typeof t!="object"?t:Array.isArray(t)?t.map(A):Object.fromEntries(Object.entries(t).map(([e,i])=>[e,A(i)])),k=t=>t>=0&&t<2**32;var c=(t,e,i)=>({type:t,contents:e&&new Uint8Array(e.flat(10)),children:i}),m=(t,e,i,r,s)=>c(t,[p(e),H(i),r??[]],s),J=t=>{let e=512;return t.fragmented?c("ftyp",[T("iso5"),o(e),T("iso5"),T("iso6"),T("mp41")]):c("ftyp",[T("isom"),o(e),T("isom"),t.holdsAvc?T("avc1"):[],T("mp41")])},R=t=>({type:"mdat",largeSize:t}),ee=t=>({type:"free",size:t}),O=(t,e,i=!1)=>c("moov",null,[re(e,t),...t.map(r=>se(r,e)),i?De(t):null]),re=(t,e)=>{let i=g(Math.max(0,...e.filter(a=>a.samples.length>0).map(a=>{let u=N(a.samples);return u.presentationTimestamp+u.duration})),_),r=Math.max(...e.map(a=>a.id))+1,s=!k(t)||!k(i),n=s?S:o;return m("mvhd",+s,0,[n(t),n(t),o(_),n(i),C(1),V(1),Array(10).fill(0),X(q),Array(24).fill(0),o(r)])},se=(t,e)=>c("trak",null,[ne(t,e),oe(t,e)]),ne=(t,e)=>{let i=N(t.samples),r=g(i?i.presentationTimestamp+i.duration:0,_),s=!k(e)||!k(r),n=s?S:o,a;return t.info.type==="video"?a=typeof t.info.rotation=="number"?W(t.info.rotation):t.info.rotation:a=q,m("tkhd",+s,3,[n(e),n(e),o(t.id),o(0),n(r),Array(8).fill(0),d(0),d(0),V(t.info.type==="audio"?1:0),d(0),X(a),C(t.info.type==="video"?t.info.width:0),C(t.info.type==="video"?t.info.height:0)])},oe=(t,e)=>c("mdia",null,[ae(t,e),ue(t.info.type==="video"?"vide":"soun"),le(t)]),ae=(t,e)=>{let i=N(t.samples),r=g(i?i.presentationTimestamp+i.duration:0,t.timescale),s=!k(e)||!k(r),n=s?S:o;return m("mdhd",+s,0,[n(e),n(e),o(t.timescale),n(r),d(21956),d(0)])},ue=t=>m("hdlr",0,0,[T("mhlr"),T(t),o(0),o(0),o(0),T("mp4-muxer-hdlr",!0)]),le=t=>c("minf",null,[t.info.type==="video"?he():de(),me(),ce(t)]),he=()=>m("vmhd",0,1,[d(0),d(0),d(0),d(0)]),de=()=>m("smhd",0,0,[d(0),d(0)]),me=()=>c("dinf",null,[fe()]),fe=()=>m("dref",0,0,[o(1)],[pe()]),pe=()=>m("url ",0,1),ce=t=>{let e=t.compositionTimeOffsetTable.length>1||t.compositionTimeOffsetTable.some(i=>i.sampleCompositionTimeOffset!==0);return c("stbl",null,[be(t),Ae(t),Be(t),Ee(t),ze(t),Oe(t),e?Ue(t):null])},be=t=>m("stsd",0,0,[o(1)],[t.info.type==="video"?Te(Pe[t.info.codec],t):Se($e[t.info.codec],t)]),Te=(t,e)=>c(t,[Array(6).fill(0),d(1),d(0),d(0),Array(12).fill(0),d(e.info.width),d(e.info.height),o(4718592),o(4718592),o(0),d(1),Array(32).fill(0),d(24),Q(65535)],[je[e.info.codec](e)]),ge=t=>t.info.decoderConfig&&c("avcC",[...new Uint8Array(t.info.decoderConfig.description)]),Ce=t=>t.info.decoderConfig&&c("hvcC",[...new Uint8Array(t.info.decoderConfig.description)]),we=t=>{if(!t.info.decoderConfig)return null;let e=t.info.decoderConfig;if(!e.colorSpace)throw new Error("'colorSpace' is required in the decoder config for VP9.");let i=e.codec.split("."),r=Number(i[1]),s=Number(i[2]),u=(Number(i[3])<<4)+(0<<1)+Number(e.colorSpace.fullRange);return m("vpcC",1,0,[p(r),p(s),p(u),p(2),p(2),p(2),d(0)])},ye=()=>{let i=(1<<7)+1;return c("av1C",[i,0,0,0])},Se=(t,e)=>c(t,[Array(6).fill(0),d(1),d(0),d(0),o(0),d(e.info.numberOfChannels),d(16),d(0),d(0),C(e.info.sampleRate)],[He[e.info.codec](e)]),xe=t=>{let e=new Uint8Array(t.info.decoderConfig.description);return m("esds",0,0,[o(58753152),p(32+e.byteLength),d(1),p(0),o(75530368),p(18+e.byteLength),p(64),p(21),H(0),o(130071),o(130071),o(92307584),p(e.byteLength),...e,o(109084800),p(1),p(2)])},ve=t=>c("mp3 ",[p(0),p(t.info.numberOfChannels),d(0),d(t.info.sampleRate),d(0)]),ke=t=>{let e=3840,i=0,r=t.info.decoderConfig.description;if(r){let s=new DataView(ArrayBuffer.isView(r)?r.buffer:r);e=s.getUint16(10,!0),i=s.getInt16(14,!0)}return c("dOps",[p(0),p(t.info.numberOfChannels),d(e),o(t.info.sampleRate),V(i),p(0)])},Ae=t=>m("stts",0,0,[o(t.timeToSampleTable.length),t.timeToSampleTable.map(e=>[o(e.sampleCount),o(e.sampleDelta)])]),Be=t=>{if(t.samples.every(i=>i.type==="key"))return null;let e=[...t.samples.entries()].filter(([,i])=>i.type==="key");return m("stss",0,0,[o(e.length),e.map(([i])=>o(i+1))])},Ee=t=>m("stsc",0,0,[o(t.compactlyCodedChunkTable.length),t.compactlyCodedChunkTable.map(e=>[o(e.firstChunk),o(e.samplesPerChunk),o(1)])]),ze=t=>m("stsz",0,0,[o(0),o(t.samples.length),t.samples.map(e=>o(e.size))]),Oe=t=>t.finalizedChunks.length>0&&B(t.finalizedChunks).offset>=2**32?m("co64",0,0,[o(t.finalizedChunks.length),t.finalizedChunks.map(e=>S(e.offset))]):m("stco",0,0,[o(t.finalizedChunks.length),t.finalizedChunks.map(e=>o(e.offset))]),Ue=t=>m("ctts",0,0,[o(t.compositionTimeOffsetTable.length),t.compositionTimeOffsetTable.map(e=>[o(e.sampleCount),o(e.sampleCompositionTimeOffset)])]),De=t=>c("mvex",null,t.map(Ie)),Ie=t=>m("trex",0,0,[o(t.id),o(1),o(0),o(0),o(0)]),G=(t,e)=>c("moof",null,[Me(t),...e.map(Ve)]),Me=t=>m("mfhd",0,0,[o(t)]),te=t=>{let e=0,i=0,r=0,s=0,n=t.type==="delta";return i|=+n,n?e|=1:e|=2,e<<24|i<<16|r<<8|s},Ve=t=>c("traf",null,[Ne(t),_e(t),Re(t)]),Ne=t=>{let e=0;e|=8,e|=16,e|=32,e|=131072;let i=t.currentChunk.samples[1]??t.currentChunk.samples[0],r={duration:i.timescaleUnitsToNextSample,size:i.size,flags:te(i)};return m("tfhd",0,e,[o(t.id),o(r.duration),o(r.size),o(r.flags)])},_e=t=>m("tfdt",1,0,[S(g(t.currentChunk.startTimestamp,t.timescale))]),Re=t=>{let e=t.currentChunk.samples.map(y=>y.timescaleUnitsToNextSample),i=t.currentChunk.samples.map(y=>y.size),r=t.currentChunk.samples.map(te),s=t.currentChunk.samples.map(y=>g(y.presentationTimestamp-y.decodeTimestamp,t.timescale)),n=new Set(e),a=new Set(i),u=new Set(r),l=new Set(s),f=u.size===2&&r[0]!==r[1],b=n.size>1,x=a.size>1,z=!f&&u.size>1,K=l.size>1||[...l].some(y=>y!==0),v=0;return v|=1,v|=4*+f,v|=256*+b,v|=512*+x,v|=1024*+z,v|=2048*+K,m("trun",1,v,[o(t.currentChunk.samples.length),o(t.currentChunk.offset-t.currentChunk.moofOffset||0),f?o(r[0]):[],t.currentChunk.samples.map((y,M)=>[b?o(e[M]):[],x?o(i[M]):[],z?o(r[M]):[],K?Y(s[M]):[]])])},ie=t=>c("mfra",null,[...t.map(Fe),Le()]),Fe=(t,e)=>m("tfra",1,0,[o(t.id),o(63),o(t.finalizedChunks.length),t.finalizedChunks.map(r=>[S(g(r.startTimestamp,t.timescale)),S(r.moofOffset),o(e+1),o(1),o(1)])]),Le=()=>m("mfro",0,0,[o(0)]),Pe={avc:"avc1",hevc:"hvc1",vp9:"vp09",av1:"av01"},je={avc:ge,hevc:Ce,vp9:we,av1:ye},$e={aac:"mp4a",opus:"Opus",mp3:"mp3 "},He={aac:xe,opus:ke,mp3:ve};var F=class{constructor(){this.buffer=null}},E=class{constructor(e){this.options=e;if(typeof e!="object")throw new TypeError("StreamTarget requires an options object to be passed to its constructor.");if(e.onData){if(typeof e.onData!="function")throw new TypeError("options.onData, when provided, must be a function.");if(e.onData.length<2)throw new TypeError("options.onData, when provided, must be a function that takes in at least two arguments (data and position). Ignoring the position argument, which specifies the byte offset at which the data is to be written, can lead to broken outputs.")}if(e.chunked!==void 0&&typeof e.chunked!="boolean")throw new TypeError("options.chunked, when provided, must be a boolean.");if(e.chunkSize!==void 0&&(!Number.isInteger(e.chunkSize)||e.chunkSize<=0))throw new TypeError("options.chunkSize, when provided, must be a positive integer.")}},L=class{constructor(e,i){this.stream=e;this.options=i;if(!(e instanceof FileSystemWritableFileStream))throw new TypeError("FileSystemWritableFileStreamTarget requires a FileSystemWritableFileStream instance.");if(i!==void 0&&typeof i!="object")throw new TypeError("FileSystemWritableFileStreamTarget's options, when provided, must be an object.");if(i&&i.chunkSize!==void 0&&(!Number.isInteger(i.chunkSize)||i.chunkSize<=0))throw new TypeError("options.chunkSize, when provided, must be a positive integer")}};var U=class{constructor(){this.pos=0;this.#t=new Uint8Array(8);this.#e=new DataView(this.#t.buffer);this.offsets=new WeakMap}#t;#e;seek(e){this.pos=e}writeU32(e){this.#e.setUint32(0,e,!1),this.write(this.#t.subarray(0,4))}writeU64(e){this.#e.setUint32(0,Math.floor(e/2**32),!1),this.#e.setUint32(4,e,!1),this.write(this.#t.subarray(0,8))}writeAscii(e){for(let i=0;i<e.length;i++)this.#e.setUint8(i%8,e.charCodeAt(i)),i%8===7&&this.write(this.#t);e.length%8!==0&&this.write(this.#t.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.pos),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.write(e.contents);else{let i=this.pos;if(this.writeBoxHeader(e,0),e.contents&&this.write(e.contents),e.children)for(let n of e.children)n&&this.writeBox(n);let r=this.pos,s=e.size??r-i;this.seek(i),this.writeBoxHeader(e,s),this.seek(r)}}writeBoxHeader(e,i){this.writeU32(e.largeSize?1:i),this.writeAscii(e.type),e.largeSize&&this.writeU64(i)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){let i=this.pos;this.seek(this.offsets.get(e)),this.writeBox(e),this.seek(i)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let i=this.measureBoxHeader(e);if(e.contents&&(i+=e.contents.byteLength),e.children)for(let r of e.children)r&&(i+=this.measureBox(r));return i}}},P=class extends U{#t;#e=new ArrayBuffer(2**16);#r=new Uint8Array(this.#e);#s=0;constructor(e){super(),this.#t=e}#i(e){let i=this.#e.byteLength;for(;i<e;)i*=2;if(i===this.#e.byteLength)return;let r=new ArrayBuffer(i),s=new Uint8Array(r);s.set(this.#r,0),this.#e=r,this.#r=s}write(e){this.#i(this.pos+e.byteLength),this.#r.set(e,this.pos),this.pos+=e.byteLength,this.#s=Math.max(this.#s,this.pos)}finalize(){this.#i(this.pos),this.#t.buffer=this.#e.slice(0,Math.max(this.#s,this.pos))}},D=class extends U{#t;#e=[];constructor(e){super(),this.#t=e}write(e){this.#e.push({data:e.slice(),start:this.pos}),this.pos+=e.byteLength}flush(){if(this.#e.length===0)return;let e=[],i=[...this.#e].sort((r,s)=>r.start-s.start);e.push({start:i[0].start,size:i[0].data.byteLength});for(let r=1;r<i.length;r++){let s=e[e.length-1],n=i[r];n.start<=s.start+s.size?s.size=Math.max(s.size,n.start+n.data.byteLength-s.start):e.push({start:n.start,size:n.data.byteLength})}for(let r of e){r.data=new Uint8Array(r.size);for(let s of this.#e)r.start<=s.start&&s.start<r.start+r.size&&r.data.set(s.data,s.start-r.start);this.#t.options.onData?.(r.data,r.start)}this.#e.length=0}finalize(){}},We=2**24,qe=2,I=class extends U{#t;#e;#r=[];constructor(e){if(super(),this.#t=e,this.#e=e.options?.chunkSize??We,!Number.isInteger(this.#e)||this.#e<2**10)throw new Error("Invalid StreamTarget options: chunkSize must be an integer not smaller than 1024.")}write(e){this.#s(e,this.pos),this.#o(),this.pos+=e.byteLength}#s(e,i){let r=this.#r.findIndex(l=>l.start<=i&&i<l.start+this.#e);r===-1&&(r=this.#n(i));let s=this.#r[r],n=i-s.start,a=e.subarray(0,Math.min(this.#e-n,e.byteLength));s.data.set(a,n);let u={start:n,end:n+a.byteLength};if(this.#i(s,u),s.written[0].start===0&&s.written[0].end===this.#e&&(s.shouldFlush=!0),this.#r.length>qe){for(let l=0;l<this.#r.length-1;l++)this.#r[l].shouldFlush=!0;this.#o()}a.byteLength<e.byteLength&&this.#s(e.subarray(a.byteLength),i+a.byteLength)}#i(e,i){let r=0,s=e.written.length-1,n=-1;for(;r<=s;){let a=Math.floor(r+(s-r+1)/2);e.written[a].start<=i.start?(r=a+1,n=a):s=a-1}for(e.written.splice(n+1,0,i),(n===-1||e.written[n].end<i.start)&&n++;n<e.written.length-1&&e.written[n].end>=e.written[n+1].start;)e.written[n].end=Math.max(e.written[n].end,e.written[n+1].end),e.written.splice(n+1,1)}#n(e){let r={start:Math.floor(e/this.#e)*this.#e,data:new Uint8Array(this.#e),written:[],shouldFlush:!1};return this.#r.push(r),this.#r.sort((s,n)=>s.start-n.start),this.#r.indexOf(r)}#o(e=!1){for(let i=0;i<this.#r.length;i++){let r=this.#r[i];if(!(!r.shouldFlush&&!e)){for(let s of r.written)this.#t.options.onData?.(r.data.subarray(s.start,s.end),r.start+s.start);this.#r.splice(i--,1)}}}finalize(){this.#o(!0)}},j=class extends I{constructor(e){super(new E({onData:(i,r)=>e.stream.write({type:"write",data:i,position:r}),chunkSize:e.options?.chunkSize}))}};var _=1e3,Xe=["avc","hevc","vp9","av1"],Ge=["aac","opus","mp3"],Ze=2082844800,Ke=["strict","offset","cross-track-offset"],Z=class{#t;#e;#r;#s;#i=null;#n=null;#o=Math.floor(Date.now()/1e3)+Ze;#h=[];#T=1;#u=[];#l=[];#m=!1;constructor(e){if(this.#g(e),e.video=A(e.video),e.audio=A(e.audio),e.fastStart=A(e.fastStart),this.target=e.target,this.#t={firstTimestampBehavior:"strict",...e},e.target instanceof F)this.#e=new P(e.target);else if(e.target instanceof E)this.#e=e.target.options?.chunked?new I(e.target):new D(e.target);else if(e.target instanceof L)this.#e=new j(e.target);else throw new Error(`Invalid target: ${e.target}`);this.#y(),this.#C()}#g(e){if(typeof e!="object")throw new TypeError("The muxer requires an options object to be passed to its constructor.");if(e.video){if(!Xe.includes(e.video.codec))throw new TypeError(`Unsupported video codec: ${e.video.codec}`);if(!Number.isInteger(e.video.width)||e.video.width<=0)throw new TypeError(`Invalid video width: ${e.video.width}. Must be a positive integer.`);if(!Number.isInteger(e.video.height)||e.video.height<=0)throw new TypeError(`Invalid video height: ${e.video.height}. Must be a positive integer.`);let i=e.video.rotation;if(typeof i=="number"&&![0,90,180,270].includes(i))throw new TypeError(`Invalid video rotation: ${i}. Has to be 0, 90, 180 or 270.`);if(Array.isArray(i)&&(i.length!==9||i.some(r=>typeof r!="number")))throw new TypeError(`Invalid video transformation matrix: ${i.join()}`);if(e.video.frameRate!==void 0&&(!Number.isInteger(e.video.frameRate)||e.video.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${e.video.frameRate}. Must be a positive integer.`)}if(e.audio){if(!Ge.includes(e.audio.codec))throw new TypeError(`Unsupported audio codec: ${e.audio.codec}`);if(!Number.isInteger(e.audio.numberOfChannels)||e.audio.numberOfChannels<=0)throw new TypeError(`Invalid number of audio channels: ${e.audio.numberOfChannels}. Must be a positive integer.`);if(!Number.isInteger(e.audio.sampleRate)||e.audio.sampleRate<=0)throw new TypeError(`Invalid audio sample rate: ${e.audio.sampleRate}. Must be a positive integer.`)}if(e.firstTimestampBehavior&&!Ke.includes(e.firstTimestampBehavior))throw new TypeError(`Invalid first timestamp behavior: ${e.firstTimestampBehavior}`);if(typeof e.fastStart=="object"){if(e.video){if(e.fastStart.expectedVideoChunks===void 0)throw new TypeError("'fastStart' is an object but is missing property 'expectedVideoChunks'.");if(!Number.isInteger(e.fastStart.expectedVideoChunks)||e.fastStart.expectedVideoChunks<0)throw new TypeError("'expectedVideoChunks' must be a non-negative integer.")}if(e.audio){if(e.fastStart.expectedAudioChunks===void 0)throw new TypeError("'fastStart' is an object but is missing property 'expectedAudioChunks'.");if(!Number.isInteger(e.fastStart.expectedAudioChunks)||e.fastStart.expectedAudioChunks<0)throw new TypeError("'expectedAudioChunks' must be a non-negative integer.")}}else if(![!1,"in-memory","fragmented"].includes(e.fastStart))throw new TypeError("'fastStart' option must be false, 'in-memory', 'fragmented' or an object.")}#C(){if(this.#e.writeBox(J({holdsAvc:this.#t.video?.codec==="avc",fragmented:this.#t.fastStart==="fragmented"})),this.#r=this.#e.pos,this.#t.fastStart==="in-memory")this.#s=R(!1);else if(this.#t.fastStart!=="fragmented"){if(typeof this.#t.fastStart=="object"){let e=this.#w();this.#e.seek(this.#e.pos+e)}this.#s=R(!0),this.#e.writeBox(this.#s)}this.#d()}#w(){if(typeof this.#t.fastStart!="object")return;let e=0,i=[this.#t.fastStart.expectedVideoChunks,this.#t.fastStart.expectedAudioChunks];for(let r of i)r&&(e+=8*Math.ceil(2/3*r),e+=4*r,e+=12*Math.ceil(2/3*r),e+=4*r,e+=8*r);return e+=4096,e}#y(){if(this.#t.video&&(this.#i={id:1,info:{type:"video",codec:this.#t.video.codec,width:this.#t.video.width,height:this.#t.video.height,rotation:this.#t.video.rotation??0,decoderConfig:null},timescale:this.#t.video.frameRate??57600,samples:[],finalizedChunks:[],currentChunk:null,firstDecodeTimestamp:void 0,lastDecodeTimestamp:-1,timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,compactlyCodedChunkTable:[]}),this.#t.audio){let e=this.#S(2,this.#t.audio.sampleRate,this.#t.audio.numberOfChannels);this.#n={id:this.#t.video?2:1,info:{type:"audio",codec:this.#t.audio.codec,numberOfChannels:this.#t.audio.numberOfChannels,sampleRate:this.#t.audio.sampleRate,decoderConfig:{codec:this.#t.audio.codec,description:e,numberOfChannels:this.#t.audio.numberOfChannels,sampleRate:this.#t.audio.sampleRate}},timescale:this.#t.audio.sampleRate,samples:[],finalizedChunks:[],currentChunk:null,firstDecodeTimestamp:void 0,lastDecodeTimestamp:-1,timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,compactlyCodedChunkTable:[]}}}#S(e,i,r){let n=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350].indexOf(i),a=r,u="";u+=e.toString(2).padStart(5,"0"),u+=n.toString(2).padStart(4,"0"),n===15&&(u+=i.toString(2).padStart(24,"0")),u+=a.toString(2).padStart(4,"0");let l=Math.ceil(u.length/8)*8;u=u.padEnd(l,"0");let f=new Uint8Array(u.length/8);for(let b=0;b<u.length;b+=8)f[b/8]=parseInt(u.slice(b,b+8),2);return f}addVideoChunk(e,i,r,s){if(!(e instanceof EncodedVideoChunk))throw new TypeError("addVideoChunk's first argument (sample) must be of type EncodedVideoChunk.");if(i&&typeof i!="object")throw new TypeError("addVideoChunk's second argument (meta), when provided, must be an object.");if(r!==void 0&&(!Number.isFinite(r)||r<0))throw new TypeError("addVideoChunk's third argument (timestamp), when provided, must be a non-negative real number.");if(s!==void 0&&!Number.isFinite(s))throw new TypeError("addVideoChunk's fourth argument (compositionTimeOffset), when provided, must be a real number.");let n=new Uint8Array(e.byteLength);e.copyTo(n),this.addVideoChunkRaw(n,e.type,r??e.timestamp,e.duration,i,s)}addVideoChunkRaw(e,i,r,s,n,a){if(!(e instanceof Uint8Array))throw new TypeError("addVideoChunkRaw's first argument (data) must be an instance of Uint8Array.");if(i!=="key"&&i!=="delta")throw new TypeError("addVideoChunkRaw's second argument (type) must be either 'key' or 'delta'.");if(!Number.isFinite(r)||r<0)throw new TypeError("addVideoChunkRaw's third argument (timestamp) must be a non-negative real number.");if(!Number.isFinite(s)||s<0)throw new TypeError("addVideoChunkRaw's fourth argument (duration) must be a non-negative real number.");if(n&&typeof n!="object")throw new TypeError("addVideoChunkRaw's fifth argument (meta), when provided, must be an object.");if(a!==void 0&&!Number.isFinite(a))throw new TypeError("addVideoChunkRaw's sixth argument (compositionTimeOffset), when provided, must be a real number.");if(this.#b(),!this.#t.video)throw new Error("No video track declared.");if(typeof this.#t.fastStart=="object"&&this.#i.samples.length===this.#t.fastStart.expectedVideoChunks)throw new Error(`Cannot add more video chunks than specified in 'fastStart' (${this.#t.fastStart.expectedVideoChunks}).`);let u=this.#p(this.#i,e,i,r,s,n,a);if(this.#t.fastStart==="fragmented"&&this.#n){for(;this.#l.length>0&&this.#l[0].decodeTimestamp<=u.decodeTimestamp;){let l=this.#l.shift();this.#a(this.#n,l)}u.decodeTimestamp<=this.#n.lastDecodeTimestamp?this.#a(this.#i,u):this.#u.push(u)}else this.#a(this.#i,u)}addAudioChunk(e,i,r){if(!(e instanceof EncodedAudioChunk))throw new TypeError("addAudioChunk's first argument (sample) must be of type EncodedAudioChunk.");if(i&&typeof i!="object")throw new TypeError("addAudioChunk's second argument (meta), when provided, must be an object.");if(r!==void 0&&(!Number.isFinite(r)||r<0))throw new TypeError("addAudioChunk's third argument (timestamp), when provided, must be a non-negative real number.");let s=new Uint8Array(e.byteLength);e.copyTo(s),this.addAudioChunkRaw(s,e.type,r??e.timestamp,e.duration,i)}addAudioChunkRaw(e,i,r,s,n){if(!(e instanceof Uint8Array))throw new TypeError("addAudioChunkRaw's first argument (data) must be an instance of Uint8Array.");if(i!=="key"&&i!=="delta")throw new TypeError("addAudioChunkRaw's second argument (type) must be either 'key' or 'delta'.");if(!Number.isFinite(r)||r<0)throw new TypeError("addAudioChunkRaw's third argument (timestamp) must be a non-negative real number.");if(!Number.isFinite(s)||s<0)throw new TypeError("addAudioChunkRaw's fourth argument (duration) must be a non-negative real number.");if(n&&typeof n!="object")throw new TypeError("addAudioChunkRaw's fifth argument (meta), when provided, must be an object.");if(this.#b(),!this.#t.audio)throw new Error("No audio track declared.");if(typeof this.#t.fastStart=="object"&&this.#n.samples.length===this.#t.fastStart.expectedAudioChunks)throw new Error(`Cannot add more audio chunks than specified in 'fastStart' (${this.#t.fastStart.expectedAudioChunks}).`);let a=this.#p(this.#n,e,i,r,s,n);if(this.#t.fastStart==="fragmented"&&this.#i){for(;this.#u.length>0&&this.#u[0].decodeTimestamp<=a.decodeTimestamp;){let u=this.#u.shift();this.#a(this.#i,u)}a.decodeTimestamp<=this.#i.lastDecodeTimestamp?this.#a(this.#n,a):this.#l.push(a)}else this.#a(this.#n,a)}#p(e,i,r,s,n,a,u){let l=s/1e6,f=(s-(u??0))/1e6,b=n/1e6,x=this.#x(l,f,e);return l=x.presentationTimestamp,f=x.decodeTimestamp,a?.decoderConfig&&(e.info.decoderConfig===null?e.info.decoderConfig=a.decoderConfig:Object.assign(e.info.decoderConfig,a.decoderConfig)),{presentationTimestamp:l,decodeTimestamp:f,duration:b,data:i,size:i.byteLength,type:r,timescaleUnitsToNextSample:g(b,e.timescale)}}#a(e,i){this.#t.fastStart!=="fragmented"&&e.samples.push(i);let r=g(i.presentationTimestamp-i.decodeTimestamp,e.timescale);if(e.lastTimescaleUnits!==null){let n=g(i.decodeTimestamp,e.timescale,!1),a=Math.round(n-e.lastTimescaleUnits);if(e.lastTimescaleUnits+=a,e.lastSample.timescaleUnitsToNextSample=a,this.#t.fastStart!=="fragmented"){let u=B(e.timeToSampleTable);u.sampleCount===1?(u.sampleDelta=a,u.sampleCount++):u.sampleDelta===a?u.sampleCount++:(u.sampleCount--,e.timeToSampleTable.push({sampleCount:2,sampleDelta:a}));let l=B(e.compositionTimeOffsetTable);l.sampleCompositionTimeOffset===r?l.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:r})}}else e.lastTimescaleUnits=0,this.#t.fastStart!=="fragmented"&&(e.timeToSampleTable.push({sampleCount:1,sampleDelta:g(i.duration,e.timescale)}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:r}));e.lastSample=i;let s=!1;if(!e.currentChunk)s=!0;else{let n=i.presentationTimestamp-e.currentChunk.startTimestamp;if(this.#t.fastStart==="fragmented"){let a=this.#i??this.#n;e===a&&i.type==="key"&&n>=1&&(s=!0,this.#c())}else s=n>=.5}s&&(e.currentChunk&&this.#f(e),e.currentChunk={startTimestamp:i.presentationTimestamp,samples:[]}),e.currentChunk.samples.push(i)}#x(e,i,r){let s=this.#t.firstTimestampBehavior==="strict",n=r.lastDecodeTimestamp===-1;if(s&&n&&i!==0)throw new Error(`The first chunk for your media track must have a timestamp of 0 (received DTS=${i}).Non-zero first timestamps are often caused by directly piping frames or audio data from a MediaStreamTrack into the encoder. Their timestamps are typically relative to the age of thedocument, which is probably what you want.

If you want to offset all timestamps of a track such that the first one is zero, set firstTimestampBehavior: 'offset' in the options.
`);if(this.#t.firstTimestampBehavior==="offset"||this.#t.firstTimestampBehavior==="cross-track-offset"){r.firstDecodeTimestamp===void 0&&(r.firstDecodeTimestamp=i);let u;this.#t.firstTimestampBehavior==="offset"?u=r.firstDecodeTimestamp:u=Math.min(this.#i?.firstDecodeTimestamp??1/0,this.#n?.firstDecodeTimestamp??1/0),i-=u,e-=u}if(i<r.lastDecodeTimestamp)throw new Error(`Timestamps must be monotonically increasing (DTS went from ${r.lastDecodeTimestamp*1e6} to ${i*1e6}).`);return r.lastDecodeTimestamp=i,{presentationTimestamp:e,decodeTimestamp:i}}#f(e){if(this.#t.fastStart==="fragmented")throw new Error("Can't finalize individual chunks if 'fastStart' is set to 'fragmented'.");if(e.currentChunk){if(e.finalizedChunks.push(e.currentChunk),this.#h.push(e.currentChunk),(e.compactlyCodedChunkTable.length===0||B(e.compactlyCodedChunkTable).samplesPerChunk!==e.currentChunk.samples.length)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:e.currentChunk.samples.length}),this.#t.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.#e.pos;for(let i of e.currentChunk.samples)this.#e.write(i.data),i.data=null;this.#d()}}#c(e=!0){if(this.#t.fastStart!=="fragmented")throw new Error("Can't finalize a fragment unless 'fastStart' is set to 'fragmented'.");let i=[this.#i,this.#n].filter(l=>l&&l.currentChunk);if(i.length===0)return;let r=this.#T++;if(r===1){let l=O(i,this.#o,!0);this.#e.writeBox(l)}let s=this.#e.pos,n=G(r,i);this.#e.writeBox(n);{let l=R(!1),f=0;for(let x of i)for(let z of x.currentChunk.samples)f+=z.size;let b=this.#e.measureBox(l)+f;b>=2**32&&(l.largeSize=!0,b=this.#e.measureBox(l)+f),l.size=b,this.#e.writeBox(l)}for(let l of i){l.currentChunk.offset=this.#e.pos,l.currentChunk.moofOffset=s;for(let f of l.currentChunk.samples)this.#e.write(f.data),f.data=null}let a=this.#e.pos;this.#e.seek(this.#e.offsets.get(n));let u=G(r,i);this.#e.writeBox(u),this.#e.seek(a);for(let l of i)l.finalizedChunks.push(l.currentChunk),this.#h.push(l.currentChunk),l.currentChunk=null;e&&this.#d()}#d(){this.#e instanceof D&&this.#e.flush()}#b(){if(this.#m)throw new Error("Cannot add new video or audio chunks after the file has been finalized.")}finalize(){if(this.#m)throw new Error("Cannot finalize a muxer more than once.");if(this.#t.fastStart==="fragmented"){for(let i of this.#u)this.#a(this.#i,i);for(let i of this.#l)this.#a(this.#n,i);this.#c(!1)}else this.#i&&this.#f(this.#i),this.#n&&this.#f(this.#n);let e=[this.#i,this.#n].filter(Boolean);if(this.#t.fastStart==="in-memory"){let i;for(let s=0;s<2;s++){let n=O(e,this.#o),a=this.#e.measureBox(n);i=this.#e.measureBox(this.#s);let u=this.#e.pos+a+i;for(let l of this.#h){l.offset=u;for(let{data:f}of l.samples)u+=f.byteLength,i+=f.byteLength}if(u<2**32)break;i>=2**32&&(this.#s.largeSize=!0)}let r=O(e,this.#o);this.#e.writeBox(r),this.#s.size=i,this.#e.writeBox(this.#s);for(let s of this.#h)for(let n of s.samples)this.#e.write(n.data),n.data=null}else if(this.#t.fastStart==="fragmented"){let i=this.#e.pos,r=ie(e);this.#e.writeBox(r);let s=this.#e.pos-i;this.#e.seek(this.#e.pos-4),this.#e.writeU32(s)}else{let i=this.#e.offsets.get(this.#s),r=this.#e.pos-i;this.#s.size=r,this.#s.largeSize=r>=2**32,this.#e.patchBox(this.#s);let s=O(e,this.#o);if(typeof this.#t.fastStart=="object"){this.#e.seek(this.#r),this.#e.writeBox(s);let n=i-this.#e.pos;this.#e.writeBox(ee(n))}else this.#e.writeBox(s)}this.#d(),this.#e.finalize(),this.#m=!0}};export{F as ArrayBufferTarget,L as FileSystemWritableFileStreamTarget,Z as Muxer,E as StreamTarget};
